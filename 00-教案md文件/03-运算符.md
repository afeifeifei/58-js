## 运算符

### 1.算术运算符

`+ - * / % ++ --`

```js
//注意 + 号在不同前后文里面的不同作用：
var a = 1 + 2; //结果：3     算术运算
var b = 1 + "2"; //结果："12"     拼接运算，+号两边任一边有字符串，+号就是拼接的作用
var c = +"1"; //结果：1   +号前面啥数据都没有时，类似于Number()的功能，将数据转换为数字，转不了得到NaN
```

```js
// 注意 - 号在不同前后文里面的不同作用：
var a = 2 - 1; //结果1  算术运算
var b = "2" - 1; //结果1  当成数字来运算
var c = -1; //结果-1  负号
var d = -"1"; //结果-1   同+号前面都没有时情况一样，只不过最终结果带上 负号 -
```

前置自增自减 和 后置自增自减

```js
//如果只看最终结果，没有区别
var x = 5;
//x ++; alert(x); //6
++ x; alert(x); //6
```

```js
//看中间过程，是有区别的
var x = 5;
//var y = x ++; alert(y); alert(x); // 5 6
var y = ++ x; alert(y); alert(x); // 6 6
```

### 2.赋值运算符

`=  +=  -=  *=  /=  %=`

`x += 10;` 相当于 `x = x + 10;` ，其他同理。

### 3.比较运算符

`==   ===   !=   !===   >   <   >=   <=`

运算完后，一定会得到一个布尔值。

### 4.逻辑运算符

`&& || !`

逻辑运算符也是通常用来做流程控制的。

### 5.逗号操作符

`,` 使用，代表语句还没结束，或者在一条语句里面执行多个事情

```js
var a = 10,b = 20,c = 30; //多个定义

var x = (1,2,3,4,5); //x值最终为5
```

### 6.案例or作业

[商品价格计算](https://afeifeifei.github.io/class-demo/js-demo/2-03-03/%E5%95%86%E5%93%81%E6%95%B0%E9%87%8F.html)

[切换按钮背景色](https://afeifeifei.github.io/class-demo/js-demo/2-03-03/%E5%88%87%E6%8D%A2%E8%83%8C%E6%99%AF%E8%89%B2.html)

[评论提交](https://afeifeifei.github.io/class-demo/js-demo/2-03-01/)

### 课外拓展-位运算

位运算直接对内存中表示数据的位进行操作，所以运算效率是最高的。

位运算时会将数值转换为32位整型来进行运算，所以位运算遇到小数时，直接处理掉小数部分当成整数来运算。并且*要是一个数的二进制表示超过32位，或者运算完后超过32位，那么就会出问题。所以不是所有的情况都适用位运算*。

32位中，前31位表示数值，第32位表示符号，例如：**3** 的32位表示为：`00000000 00000000 00000000 00000011`。（PS：短除法求二进制）。

负数会以**二进制补码**的形式来表示，规则是：

```js
//以 -3 为例子

//第一步：取负数对应的正数的二进制码，例子中取 3 的二进制码
00000000 00000000 00000000 00000011 //3的二进制码

//第二步：取得到的二进制码的反码，0变1  1变0
11111111 11111111 11111111 11111100 //二进制反码

//第三步：反码加1
11111111 11111111 11111111 11111101 //得到-3的二进制表示
```

位运算操作符：按位非`~` 、按位与`&`、按位或`|`、按位异或`^`、左移`<<`、无符号右移`>>>`、有符号右移`>>`。

- **~ 按位非**

每一位取反，例：

```js
var a = 12;
var b = ~a;

// 12的二进制表示：     00000000 00000000 00000000 00001100
// 按位非得到最终结果： 11111111 11111111 11111111 11110011  

//因为 第32位是1，代表负数，那这个负数是多少呢？按照上面的办法我们可以反推回来：
//负数码减-1：         11111111 11111111 11111111 11110010
//结果取反码：         00000000 00000000 00000000 00001101
//表示的正数是：13，所以该负数为  -13

alert(b); //验证一下
```

所以按位非的结果为 该数负数减1， `~12 === -13` `~-5 === 4`

- **& 按位与**

与是两个数之间的操作，两个数每一位的值 1 1 得1   1 0得0   0 1得0  0 0得0，例：

```js
var a = 11 & 4;

//11的二进制  00000000 00000000 00000000 00001011
//4 的二进制  00000000 00000000 00000000 00000100
//按位与      00000000 00000000 00000000 00000000
//结果为 0

alert( a ); //验证一下
```

- **| 按位或    ^ 按位异或**

这就和上面一个道理了，或都应该能理解 11得1  10得1   01得1  00得0，

异或：11得0   10得1    01得1   00得0   

- **<< 左移**

二进制码左移几位，右边的空位补0

```js
var a = 4 << 2;

//4的二进制码： 00000000 00000000 00000000 00000100
//左移2位：  00 00000000 00000000 00000000 000100    //左边超过32的就不用管了，右边少于8位的补0    
//得到：        00000000 00000000 00000000 00010000  // 16

alert(a); //验证一下
```

左移是*不会改变符号位*的，相当于原来的数乘以 2的几次方。

- **>>> 无符号右移    >> 有符号右移**

有符号右移：不动符号位，二进制码右移，左侧补0，原理和上述一样。

无符号右移：移动所有位包括符号位，整体右移，左侧补0，所以如果负数进行无符号右移，会得到一个很蛋疼的数。

- 位运算的运用

左移右移来进行相对于 2的乘方 运算。

强制取整，位运算直接会舍弃小数，例如：`var a = 12.12 | 0;`，直接舍弃小数位，并且或上0不会影响整数位。

判断奇偶，奇数 & 1 一定是 1            偶数 & 1一定是 0

……